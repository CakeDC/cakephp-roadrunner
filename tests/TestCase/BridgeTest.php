<?php

namespace CakeDC\Roadrunner\Test\TestCase;

use Cake\Core\Configure;
use Cake\Http\ServerRequest;
use Cake\Http\ServerRequestFactory;
use Cake\TestSuite\TestCase;
use CakeDC\Roadrunner\Bridge;
use CakeDC\Roadrunner\Exception\CakeRoadrunnerException;
use CakeDC\Roadrunner\Test\ServerRequestHelper;
use Laminas\Diactoros\StreamFactory;
use Laminas\Diactoros\UploadedFile;
use Laminas\Diactoros\Uri;

class BridgeTest extends TestCase
{
    private string $rootDir;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        Configure::write('Error', []);
        Configure::write('debug', true);
        Configure::write('App.namespace', 'App\\');
        $this->rootDir = dirname(__DIR__ . '../') . '/test_app';
    }

    public function test_handle(): void
    {
        $request = ServerRequestFactory::fromGlobals(ServerRequestHelper::defaultServerParams());
        $response = (new Bridge($this->rootDir))->handle($request);
        $this->assertEquals(200, $response->getStatusCode());
        $this->assertEquals(['hello' => 'world'], json_decode((string) $response->getBody(), true));
    }

    public function test_handle_with_trailing_root_directory_slash(): void
    {
        $request = ServerRequestFactory::fromGlobals(ServerRequestHelper::defaultServerParams());
        $response = (new Bridge($this->rootDir . '/'))->handle($request);
        $this->assertEquals(200, $response->getStatusCode());
        $this->assertEquals(['hello' => 'world'], json_decode((string) $response->getBody(), true));
    }

    public function test_handle_http_write_methods(): void
    {
        foreach (['POST', 'PUT', 'PATCH'] as $method) {
            $data = ['hello' => $method];
            $request = ServerRequestFactory::fromGlobals(
                ServerRequestHelper::defaultServerParams([
                    'REQUEST_URI' => 'http://localhost:8080/write.json',
                    'REQUEST_METHOD' => $method,
                ])
            );

            $request = $request->withBody((new StreamFactory())->createStream(json_encode($data)));
            $request = $request->withHeader('Content-Type', 'application/json');
            $response = (new Bridge($this->rootDir))->handle($request);
            $this->assertEquals(200, $response->getStatusCode());
            $this->assertEquals($data, json_decode((string) $response->getBody(), true));
        }
    }

    public function test_handle_http_delete_method(): void
    {
        $request = ServerRequestFactory::fromGlobals(
            ServerRequestHelper::defaultServerParams([
                'REQUEST_URI' => 'http://localhost:8080/delete.json',
                'REQUEST_METHOD' => 'DELETE',
            ])
        );

        $response = (new Bridge($this->rootDir))->handle($request);
        $this->assertEquals(204, $response->getStatusCode());
        $this->assertEquals('', (string) $response->getBody());
    }

    public function test_construct_throws_exception_when_root_dir_not_found(): void
    {
        $rootDir = '/dev/null/cakephp-roadrunner-'. md5((string)microtime(true));
        $this->expectException(CakeRoadrunnerException::class);
        $this->expectExceptionMessage(sprintf(CakeRoadrunnerException::ROOT_DIR_NOT_FOUND, $rootDir));
        (new Bridge($rootDir));
    }

    /**
     * @todo this is difficult to test
     * @return void
     */
    public function test_construct_throws_exception_when_application_instance_not_created(): void
    {
        $this->markTestSkipped('@todo: difficult to test');
        $this->expectException(CakeRoadrunnerException::class);
        $this->expectExceptionMessage(CakeRoadrunnerException::APP_INSTANCE_NOT_CREATED);
        (new Bridge($this->rootDir));
    }

    public function test_convert_request_adds_host_header_correctly(): void
    {
        $request = (new ServerRequest())->withUri(new Uri('http://website.com/test.json'));

        $convertedRequest = Bridge::convertRequest($request);

        $this->assertEquals('website.com', $convertedRequest->getHeaderLine('Host'));
    }

    public function test_convert_request_adds_uploaded_files_to_parsed_body(): void
    {
        $stream = (new StreamFactory())->createStream('test contents');
        $request = (new ServerRequest())->withUploadedFiles([
            'uploadedFileField' => new UploadedFile(
                $stream,
                $stream->getSize(),
                UPLOAD_ERR_OK,
                clientFilename: 'test.txt'
            ),
        ]);

        $convertedRequest = Bridge::convertRequest($request);
        $parsedBody = $convertedRequest->getParsedBody();

        $this->assertArrayHasKey('uploadedFileField', $parsedBody);

        $uploadedFile = $parsedBody['uploadedFileField'];
        $this->assertInstanceOf(UploadedFile::class, $uploadedFile);
        $this->assertEquals('test.txt', $uploadedFile->getClientFilename());
    }

    public function test_convert_request_should_not_attempt_to_parse_request_body_when_is_put_with_urlencoded_parameters(): void
    {
        $urlEncodedParameters = [
            'test' => 123,
        ];

        // Roadrunner sends the request body encoded with JSON, even when it was originally parsed
        // from a `application/x-www-form-urlencoded` request
        $stream = (new StreamFactory())->createStream(json_encode($urlEncodedParameters));
        $request = (new ServerRequest())
            ->withMethod('PUT')
            ->withHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8')
            ->withBody($stream)
            ->withParsedBody($urlEncodedParameters);

        $convertedRequest = Bridge::convertRequest($request);
        $parsedBody = $convertedRequest->getParsedBody();

        $this->assertEquals($urlEncodedParameters, $parsedBody);
    }
}
